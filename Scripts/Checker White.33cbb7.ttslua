--The "Build Deck" button at the top-left

decklistTextGUID = '8848e5'
zoneBagGUID = '36c7bf'

CACHE = {
    object = {},
    bag = {}
}

--function onLoad()

--end

function buildDeck(obj, player)
    local textBox = getObjectCache(decklistTextGUID)

    if textBox == nil then
        return
    end

    buildBagList()

    CACHE.pos = obj.getPosition()

    if string.find(textBox.TextTool.getValue(), 'Main Deck') then
        startLuaCoroutine(self, 'fetchCard')
    else
        broadcastToColor('Invalid Deck. Use RINGSDB.COM', player)
    end
end

function buildBagList()
    local zone = getObjectCache(zoneBagGUID)

    CACHE.bag = {}

    if zone ~= nil then
        local objects = zone.getObjects()

        for i = 1, #objects do
            if objects[i].tag == 'Bag' then
                CACHE.bag[getKey(objects[i].getName())] = objects[i]
            end
        end
    end
end

function fetchCard()
    local textBox = getObjectCache(decklistTextGUID)

    if textBox == nil then
        return 1
    end

    local deckData = textBox.TextTool.getValue()
    local processedDeck = {}

    for line in string.gmatch(deckData, '[^\r\n]+') do
        local c, n, k = line:match("(%d+)x%s+(.-)%s+%((.*)%)")

        if c ~= nil then
            table.insert(processedDeck, {
                bag = getKey(k),
                name = getKey(n),
                count = tonumber(c)
            })
        else
            n, k = line:match("^%s*(.-)%s+%((.*)%)")

            if k ~= nil and tonumber(k) == nil then
                table.insert(processedDeck, {
                    bag = getKey(k),
                    name = getKey(n),
                    count = 0
                })
            end
        end
    end

    local pos = CACHE.pos
    local offsetY = 2

    for _, v in ipairs(processedDeck) do
        local bag = CACHE.bag[v.bag]

        if bag ~= nil then
            local cards = bag.getObjects()

            for i = 1, #cards do
                if v.name == getKey(cards[i].name) then
                    local cnt = v.count

                    if cnt == 0 then
                        cnt = 1
                    end

                    local card

                    for z = 1, cnt do
                        local params = {
                            smooth = false,
                            index = cards[i].index,
                        }

                        if v.count == 0 then
                            params.position = { pos.x - 2.5, pos.y + offsetY, pos.z + 7 }
                            params.rotation = { 0, 180, 0 }
                        else
                            params.position = { pos.x + 2.5, pos.y + offsetY, pos.z + 7 }
                            params.rotation = { 0, 180, 180 }
                        end

                        if z > 1 and card ~= nil then
                            local clone = card:clone()
                            clone.setPosition(params.position)
                        else
                            card = getCard(bag, params)
                        end

                        offsetY = offsetY + 0.25

                        coroutine.yield(0)
                    end
                end
            end
        end
    end

    return 1
end

function getCard(bag, takeParams)
    local pos = bag.getPosition()

    local bagClone = bag:clone()
    bagClone.setPosition({ pos.x, pos.y + 10, pos.z })

    local card = bagClone.takeObject(takeParams)

    bagClone.destruct()

    return card
end

function setString(str)
    --gsub('[%p%c%s]', '')
    str = string.lower(str)
    str = str:gsub('[%p%c%s]', '')
    return str
end

function stripChars(str)
    local tableAccents = {}
    local normalizedString = ""

    tableAccents["à"] = "a"
    tableAccents["á"] = "a"
    tableAccents["â"] = "a"
    tableAccents["ã"] = "a"
    tableAccents["ä"] = "a"
    tableAccents["ç"] = "c"
    tableAccents["è"] = "e"
    tableAccents["é"] = "e"
    tableAccents["ê"] = "e"
    tableAccents["ë"] = "e"
    tableAccents["ì"] = "i"
    tableAccents["í"] = "i"
    tableAccents["î"] = "i"
    tableAccents["ï"] = "i"
    tableAccents["ñ"] = "n"
    tableAccents["ò"] = "o"
    tableAccents["ó"] = "o"
    tableAccents["ô"] = "o"
    tableAccents["õ"] = "o"
    tableAccents["ö"] = "o"
    tableAccents["ù"] = "u"
    tableAccents["ú"] = "u"
    tableAccents["ú"] = "u"
    tableAccents["û"] = "u"
    tableAccents["ü"] = "u"
    tableAccents["ý"] = "y"
    tableAccents["ÿ"] = "y"
    tableAccents["À"] = "A"
    tableAccents["Á"] = "A"
    tableAccents["Â"] = "A"
    tableAccents["Ã"] = "A"
    tableAccents["Ä"] = "A"
    tableAccents["Ç"] = "C"
    tableAccents["È"] = "E"
    tableAccents["É"] = "E"
    tableAccents["Ê"] = "E"
    tableAccents["Ë"] = "E"
    tableAccents["Ì"] = "I"
    tableAccents["Í"] = "I"
    tableAccents["Î"] = "I"
    tableAccents["Ï"] = "I"
    tableAccents["Ñ"] = "N"
    tableAccents["Ò"] = "O"
    tableAccents["Ó"] = "O"
    tableAccents["Ô"] = "O"
    tableAccents["Õ"] = "O"
    tableAccents["Ö"] = "O"
    tableAccents["Ù"] = "U"
    tableAccents["Ú"] = "U"
    tableAccents["Û"] = "U"
    tableAccents["Ü"] = "U"
    tableAccents["Ý"] = "Y"

    for strChar in string.gmatch(str, "([%z\1-\127\194-\244][\128-\191]*)") do
        if tableAccents[strChar] ~= nil then
            normalizedString = normalizedString .. tableAccents[strChar]
        else
            normalizedString = normalizedString .. strChar
        end
    end

    return normalizedString
end

function getObjectCache(id)
    if CACHE.object[id] == nil then
        CACHE.object[id] = getObjectFromGUID(id)
    end
    return CACHE.object[id]
end

function getKey(name)
    return setString(stripChars(name))
end













--[[ Lua code. See documentation: https://api.tabletopsimulator.com/ --]]

--[[ The onLoad event is called after the game save finishes loading. --]]
function onLoad()
  print('Loading Deck Builder')
  self.createButton({
      click_function = 'buildDeck',
      function_owner = self,
      label = 'Build Deck',
      position = { 0, 0.6, 0 },
      rotation = { 0, 0, 0 },
      color = { 1, 1, 1},
      font_color = { 0, 0, 0 },
      width = 1000,
      height = 350,
      font_size = 200,
      scale = { 3.8, 3.8, 3.8 }
  })
  init()
  -- Setup...
  publicDeckURL="https://ringsdb.com/api/public/decklist/"
  privateDeckURL="https://ringsdb.com/deck/view/"
  cardURL="https://ringsdb.com/api/public/card/"
  --subnameCards={{name="Randolph Carter",xp=0},{name="Dream Diary",xp=3},{name="Relic of Ages",xp=0},{name="The Necronomicon",xp=0},{name="Archaic Glyphs",xp=3},{name="Strange Solution",xp=4},{name="Forbidden Tome",xp=3},{name="Relic of Ages",xp=0}, {name="Ancient Stone",xp=4}, {"Dream Diary",xp=0},{name="Empower Self",xp=2}}
  --extraPermanents={["Duke"]=true,["Sophie"]=true,["Gate Box"]=true,["Dark Insight"]=true}
  --multiClassCards={{name=".45 Thompson",xp=3},{name="Scroll of Secrets",xp=3},{name="Tennessee Sour Mash",xp=3},{name="Enchanted Blade",xp=3},{name="Grisly Totem",xp=3}}
  --returningCards={{name="On Your Own"}}
  --advancedSignatures={{name="Daisy's Tote Bag"},{name="The Necronomicon"},{name="On the Lam"},{name="Hospital Debts"},{name="Dark Memory"},{name="Heirloom of Hyperborea"}}
  --bondedCardsOneThree={{name="Hallowed Mirror",bondedName="Soothing Melody",bondedCode=05314},{name="Occult Lexicon",bondedName="Blood-Rite",bondedCode=05317},{name="The Hungering Blade",bondedName="Bloodlust",bondedCode=06019},{name="Nightmare Bauble",bondedName="Dream Parasite",bondedCode=06331},{name="Miss Doyle",bondedName="Hope",bondedCode=06031,bondedNameSecond="Zeal",bondedCodeSecond=06032,bondedNameThird="Augur",bondedCodeThird=06033}}
  --bondedCardsBoolean = {{name="Gate Box",bondedName="Dream-Gate",bondedCode="06015a",bondCount=1},{name="Crystallizer of Dreams",bondedName="Guardian of the Crystallizer",bondedCode=06025,bondCount=2},{name="Dream Diary",bondedName="Essence of the Dream",bondedCode=06113,bondCount=1},{name="Empty Vessel",bondedName="Wish Eater",bondedCode=06277,bondCount=1},{name="Segment of Onyx",bondedName="Pendant of the Queen",bondedCode=06022,bondCount=1},{name="Stargazing",bondedName="The Stars Are Right",bondedCode=06028,bondCount=2},{name="Summoned Hound",bondedName="Unbound Beast",bondedCode=06283,bondCount=2}}
  privateDeck = true

  buildBagList()
  makeText()
  makeButton()
  makeCheckboxPP()

  --all_cards_bag = getObjectFromGUID("36c7bf")
end

function init()
  cardList = {}
  doneSlots = 0
  totalCards = 0
end

-- Previously this was "spawnZone"
function get_deck()
    if deckID == nil then
       broadcastToAll("Deck ID required", {0.5,0.5,0.5})
       return 1
    end

--params.position = { pos.x - 2.5, pos.y + offsetY, pos.z + 7 }
--params.rotation = { 0, 180, 0 }
    heroPos = self.positionToWorld({0,0.5,0})
    deckPos = self.positionToWorld({0,0,0})
    sideboardPos = self.positionToWorld({0,-0.5,0})


    -- Get deck from RingsDB..
    local deckURL
    if privateDeck then deckURL = privateDeckURL
    else deckURL = publicDeckURL
    end

    WebRequest.get(deckURL .. deckID, self, 'deckReadCallback')
end

function deckReadCallback(req)
  -- Result check..
  if req.is_done and not req.is_error
  then
    if string.find(req.text, "<!DOCTYPE html>")
    then
      broadcastToAll("Private deck "..deckID.." is not shared", {0.5,0.5,0.5})
      return
    end
    JsonDeckRes = JSON.decode(req.text)
  else
    print (req.error)
    return
  end
  if (JsonDeckRes == nil)
  then
    broadcastToAll("Deck not found!", {0.5,0.5,0.5})
    return
  else
    print("Found decklist: "..JsonDeckRes.name)
  end
  -- Count number of cards in decklist
  numCards=0
  for cardid,number in
  pairs(JsonDeckRes.heroes)
  do
      numCards = numCards + 1
  end
  for cardid,number in
  pairs(JsonDeckRes.slots)
  do
    numCards = numCards + 1
  end
  for cardid,number in
  pairs(JsonDeckRes.sideslots)
  do
    numCards = numCards + 1
  end

  -- Save card id, number in table and request card info from ArkhamDB
  for cardID,number in pairs(JsonDeckRes.heroes)
  do
      local row = {}
      row.cardName = ""
      row.cardCount = number
      row.type = "hero"
      cardList[cardID] = row
      WebRequest.get(cardURL .. cardID, self, 'cardReadCallback')
      totalCards = totalCards + number
  end
  for cardID,number in pairs(JsonDeckRes.slots)
  do
    local row = {}
    row.cardName = ""
    row.cardCount = number
    row.type = "slot"
    cardList[cardID] = row
    WebRequest.get(cardURL .. cardID, self, 'cardReadCallback')
    totalCards = totalCards + number
  end
  for cardID,number in pairs(JsonDeckRes.sideslots)
  do
    local row = {}
    row.cardName = ""
    row.cardCount = number
    row.type = "sideboard"
    cardList[cardID] = row
    WebRequest.get(cardURL .. cardID, self, 'cardReadCallback')
    totalCards = totalCards + number
  end
end

function cardReadCallback(req)
  -- Result check..
  if req.is_done and not req.is_error
  then
    -- Find unicode before using JSON.decode since it doesnt handle hex UTF-16
    local tmpText = string.gsub(req.text,"\\u(%w%w%w%w)", convertHexToDec)
    JsonCardRes = JSON.decode(tmpText)
  else
    print(req.error)
    return
  end

  cardList[JsonCardRes.code].cardName = getKey(JsonCardRes.name)
  cardList[JsonCardRes.code].packName = getKey(JsonCardRes.pack_name)

  --TODO: Remove this oddity:
  if JsonCardRes.code == "17062" then
      cardList[JsonCardRes.code].cardName = "dnedainlookout"
  end
  -- Check for more complicated bonding cards
--  for k,v in pairs(bondedCardsBoolean) do
--    if (v.name == JsonCardRes.real_name and cardList[v.bondedCode] == nil)
--    then
--      local row = {}
--      row.cardName = v.bondedName
--      row.cardCount = v.bondCount
--      row.permanent = true
--      cardList[v.bondedCode] = row
--    end
--  end

  -- Update number of processed slots, if complete, start building the deck
  doneSlots = doneSlots + 1
  if (doneSlots == numCards)
  then
    createDeck()
  end
end

function createDeck()
  for k,v in pairs(cardList) do
    searchForCard(v.cardName, v.packName, v.cardCount, v.type)
  end
end

function searchForCard(cardName, packName, cardCount, type)
  local bag = CACHE.bag[packName]
  local allCards = bag.getObjects()

  for k,v in pairs(allCards) do
    --for i = 1, #allCards do
    if packName == "beneaththesands" then
        print("Looking for "..cardName.." Found: "..v.name.." OR "..getKey(v.name))
    end
    if getKey(v.name) == cardName then
        bag.takeObject({
          position = {0, 1.5, 0},
          callback = 'cardTaken',
          callback_owner=self,
          index = v.index,
          smooth = false,
          params = { cardName, cardCount, type, bag, v.guid }
        })
        print('Added '.. cardCount .. ' of ' .. cardName .. ' from ' .. packName)
        return
    end
  end
  broadcastToAll("Card not found: "..cardName.." from "..packName, {0.5,0.5,0.5})
end

function cardTaken(card, params)
  -- Check destination deck (permanent?)
    local destPos
    local rotation = self.getRotation()
    if (params[3] == "hero") then -- permanent card
        destPos = heroPos
    elseif (params[3] == "slot") then
        destPos = deckPos
        rotation = rotation + Vector(0, 0, 180) -- Flip non-permanents facedown
    else
        destPos = sideboardPos
    end

    for i=1, params[2] do
        local cloneParams = {}
        cloneParams.position=destPos
        card.clone(cloneParams).setRotation(rotation)
    end
    params[4].putObject(card)

    --if (card.getName() == params[1]) then
    --    for i=1, params[2] do
    --        local cloneParams = {}
    --        cloneParams.position=destPos
    --        card.clone(cloneParams).setRotation(rotation)
    --    end
    --params[4].putObject(card)
    --else
    --    print('Wrong card: ' .. card.getName())
    --    params[4].putObject(card)
    --end
end

function makeText()
  -- Create textbox
  local input_parameters = {}
  input_parameters.input_function = "inputTyped"
  input_parameters.function_owner = self
  input_parameters.position = {15,0.5,0}
  input_parameters.width = 2200
  input_parameters.scale = {3,3,3}
  input_parameters.height = 500
  input_parameters.font_size = 450
  input_parameters.tooltip = "*****PLEASE USE AN UNPUBLISHED DECK IF JUST FOR TTS TO AVOID FLOODING ARKHAMDB PUBLISHED DECK LISTS!*****\nInput deck ID from ArkhamDB URL of the deck\nExample: For the URL 'https://arkhamdb.com/decklist/view/101/knowledge-overwhelming-solo-deck-1.0', you should input '101'"
  input_parameters.alignment = 3 -- (1 = Automatic, 2 = Left, 3 = Center, 4 = Right, 5 = Justified) –Optional
  input_parameters.value="123456"
  input_parameters.label = "INPUT HERE"
  input_parameters.color = {0.9,0.7,0.5}
  input_parameters.validation = 2
  self.createInput(input_parameters)
end

function inputTyped(objectInputTyped, playerColorTyped, input_value, selected)
    deckID = input_value
end

function makeButton()
  -- Create Button
  local button_parameters = {}
  button_parameters.click_function = "buttonClicked"
  button_parameters.function_owner = self
  button_parameters.position = {15,0.5,-2}
  button_parameters.width = 900
  button_parameters.height = 270
  button_parameters.tooltip = "Click to build your deck!"
  button_parameters.label = "Build"
  button_parameters.scale = {3,3,3}
  self.createButton(button_parameters)
end

function buttonClicked()
  -- Reset
  init()

  get_deck()
end

--function onLoad()
--    self.createButton({
--        click_function = 'buildDeck',
--        function_owner = self,
--        label = 'Build Deck',
--        position = { 0, 0.6, 0 },
--        rotation = { 0, 0, 0 },
--        color = { 1, 1, 1},
--        font_color = { 0, 0, 0 },
--        width = 1000,
--        height = 350,
--        font_size = 200,
--        scale = { 3.8, 3.8, 3.8 }
--    })
--end

function makeCheckboxPP()
  -- Create Private/Published checkbox
  local checkbox_parameters = {}
  checkbox_parameters.click_function = "checkboxPPClicked"
  checkbox_parameters.function_owner = self
  --checkbox_parameters.position = {-0.33,0.1,-0.255}
  checkbox_parameters.position = {15,0.6,-5}
  checkbox_parameters.width = 900
  checkbox_parameters.height = 275
  checkbox_parameters.tooltip = "Click to toggle Private/Published deck ID"
  checkbox_parameters.label = "Private"
  checkbox_parameters.font_size = 200
  checkbox_parameters.scale = {3.0,3.0,3.0}
  checkbox_parameters.color = {1,1,1}
  checkbox_parameters.hover_color = {0.4,0.6,0.8}
  self.createButton(checkbox_parameters)
end

function checkboxPPClicked()
  buttons = self.getButtons()
  for k,v in pairs(buttons) do
    if (v.label == "Private") then
      local button_parameters = {}
      button_parameters.label = "Published"
      button_parameters.index = v.index
      self.editButton(button_parameters)
      privateDeck = false
    else
      if (v.label == "Published") then
        local button_parameters = {}
        button_parameters.label = "Private"
        button_parameters.index = v.index
        self.editButton(button_parameters)
        privateDeck = true
      end
    end
  end
end

-- Function to convert utf-16 hex to actual character since JSON.decode doesn't seem to handle utf-16 hex very well..
function convertHexToDec(a)
  return string.char(tonumber(a,16))
end
