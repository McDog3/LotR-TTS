-- ~~~~~~
-- Script by dzikakulka
-- Issues, history at: http://github.com/tjakubo2/TTS_lib
--
-- Framework for binding functions to scripting key combination press and/or release easily
-- Description and usage in README.md in this lib folder in repository
-- ~~~~~~

SHADOW_CARD_PILE = '417a35'
SECONDARY_SHADOW_CARD_PILE = '8c1795'

PLAYTEST_BUILDER = '15426a'
-- Testing flags
flags = {
  -- setTestingDeckIds = true,
  -- heroSpawnTesting = true,
  -- encounterSpawnTesting = true,
  ui = {
    -- main = true,
    -- player = true,
    -- encounter = true,
  }
}

function onLoad()
    count = 0
    spawnTest = true
        Hotkey.Bind({1}, spawnShadow, 'up')
        Hotkey.Bind({2}, spawn2ndShadow, 'up')
    MegaFreeze()
end

if not package.loaded['Hotkey'] then
    Hotkey = {}
    package.loaded['Hotkey'] = Hotkey

    -- Register the press and call any press functions
    Hotkey.onScriptingButtonDown = function(index, playerColor)
        if playerColor ~= 'Grey' then
            Hotkey.PressButton(index, playerColor)
            if Hotkey.map[Hotkey.stateTable[playerColor] .. 'D'] then
                for _,handler in pairs(Hotkey.map[Hotkey.stateTable[playerColor] .. 'D']) do
                    handler(playerColor, 'down', index)
                end
            end
        end
    end

    -- Call any release functions and then register release
    Hotkey.onScriptingButtonUp = function(index, playerColor)
        if playerColor ~= 'Grey' then
            if Hotkey.map[Hotkey.stateTable[playerColor] .. 'U'] then
                for _,handler in pairs(Hotkey.map[Hotkey.stateTable[playerColor] .. 'U']) do
                    handler(playerColor, 'up', index)
                end
            end
            Hotkey.ReleaseButton(index, playerColor)
        end
    end

    -- Hook into event functions, use EventSub if present
    if package.loaded['EventSub'] then
        EventSub.Register('onScriptingButtonDown', Hotkey.onScriptingButtonDown)
        EventSub.Register('onScriptingButtonUp', Hotkey.onScriptingButtonUp)
    else
        assert(onScriptingButtonDown == nil, 'Hotkey init: Event onScriptingButtonDown already defined!')
        function onScriptingButtonDown(...)
            Hotkey.onScriptingButtonDown(table.unpack({...}))
        end
        assert(onScriptingButtonUp == nil, 'Hotkey init: Event onScriptingButtonUp already defined!')
        function onScriptingButtonUp(...)
            Hotkey.onScriptingButtonUp(table.unpack({...}))
        end
    end

    -- Amount of available buttons
    Hotkey.keyCount = 10
    -- Create a string representing press combination for easy comparision
    Hotkey.PressString = function(combination)
        local out = ''
        for k=1,Hotkey.keyCount do
            out = out .. '-'
        end
        if combination then
            for _,index in pairs(combination) do
                out = out:sub(1, index-1) .. '+' .. out:sub(index+1)
            end
        end
        return out
    end

    -- Main table containing info on player keypresses
    Hotkey.stateTable =  {
            ['White'] = Hotkey.PressString(),
            ['Brown'] = Hotkey.PressString(),
            ['Red'] = Hotkey.PressString(),
            ['Orange'] = Hotkey.PressString(),
            ['Yellow'] = Hotkey.PressString(),
            ['Green'] = Hotkey.PressString(),
            ['Teal'] = Hotkey.PressString(),
            ['Blue'] = Hotkey.PressString(),
            ['Pink'] = Hotkey.PressString(),
            ['Purple'] = Hotkey.PressString(),
            ['Black'] = Hotkey.PressString()
    }

    -- Map of combination strings to a table of handler functions
    Hotkey.map = {}

    -- Add a handler function for a combination
    Hotkey.Bind = function(combination, handler, direction)
        assert(type(combination) == 'table', 'Hotkey.Bind: combination not a table!')
        assert(type(handler) == 'function', 'Hotkey.Bind: handler not a function!')
        direction = direction or 'down'
        local pressString = Hotkey.PressString(combination)
        if direction == 'up' or direction == 'any' then
            if not Hotkey.map[pressString .. 'U'] then
                Hotkey.map[pressString .. 'U'] = {}
            end
            table.insert(Hotkey.map[pressString .. 'U'], handler)
        end
        if direction == 'down' or direction == 'any' then
            if not Hotkey.map[pressString .. 'D'] then
                Hotkey.map[pressString .. 'D'] = {}
            end
            table.insert(Hotkey.map[pressString .. 'D'], handler)
        end
    end

    -- Register button press in state tables
    Hotkey.PressButton = function(index, playerColor)
        if Hotkey.stateTable then
            Hotkey.stateTable[playerColor] = Hotkey.stateTable[playerColor]:sub(1, index-1) .. '+' ..  Hotkey.stateTable[playerColor]:sub(index+1, -1)
        end
    end
    -- Register button release in state tables
    Hotkey.ReleaseButton = function(index, playerColor)
        if Hotkey.stateTable then
            Hotkey.stateTable[playerColor] = Hotkey.stateTable[playerColor]:sub(1, index-1) .. '-' ..  Hotkey.stateTable[playerColor]:sub(index+1, -1)
        end
    end
end

function spawnShadow(playerColor, direction, lastPressIndex)
    function spawnShadow_afterCount(prams)
        local num = prams.n
        local pos = prams.p
        pos.y = 4
        for _, d in pairs(getObjectFromGUID(SHADOW_CARD_PILE).getObjects()) do
            if d.tag == 'Deck' then
                if #d.getObjects() < num then num = #d.getObjects() end
                local p = {position=pos, rotation={0,180,180}}
                for i=1, num, 1 do
                    d.takeObject(p)
                    p.position.x = p.position.x
                end
            elseif d.tag == 'Card' then
                d.setPositionSmooth(pos)
                d.setRotation({0,180,180})
            end
        end
        count = 0
        spawnTest = true
    end
    count = count + 1
    if spawnTest then pos = Player[playerColor].getPointerPosition() spawnTest = false end
    local prams = {n=count, p=pos}
    Timer.destroy("spawnShadow1"..playerColor)
    Timer.create({
        identifier="spawnShadow"..playerColor, delay=0.2,
        function_name="spawnShadow_afterCount", function_owner=self, parameters = prams,
    })
end

function spawn2ndShadow(playerColor, direction, lastPressIndex)
    function spawnShadow_afterCount(prams)
        local num = prams.n
        local pos = prams.p
        pos.y = 4
        for _, d in pairs(getObjectFromGUID(SECONDARY_SHADOW_CARD_PILE).getObjects()) do
            if d.tag == 'Deck' then
                if #d.getObjects() < num then num = #d.getObjects() end
                local p = {position=pos, rotation={0,180,180}}
                for i=1, num, 1 do
                    d.takeObject(p)
                    p.position.x = p.position.x
                end
            elseif d.tag == 'Card' then
                d.setPositionSmooth(pos)
                d.setRotation({0,180,180})
            end
        end
        count = 0
        spawnTest = true
    end
    count = count + 1
    if spawnTest then pos = Player[playerColor].getPointerPosition() spawnTest = false end
    local prams = {n=count, p=pos}
    Timer.destroy("spawnShadow1"..playerColor)
    Timer.create({
        identifier="spawnShadow"..playerColor, delay=0.2,
        function_name="spawnShadow_afterCount", function_owner=self, parameters = prams,
    })
end

Total = getObjectFromGUID('639e23')
Levels = getObjectFromGUID('5a5f95')
Bonus = getObjectFromGUID('639e23')

function addUp() -- TODO: Is this still used?
    Total.setValue( Levels.getValue() + Bonus.GetValue() )
end

function MegaFreeze()
    local freezeByZone = {'36c7bf'}
    --black table, left edge, right edge, top edge, vd, aside, floor (table), secret bag under the black table, another secret bag under the black table
    local freezeByGUID = {'23a43c', 'b37a40', 'b3e425', 'e577da', '2a71e5', 'eef28d', '1d2bbf', '9ef8b0', 'ce199b'}

    for _, obj in pairs(getAllObjects()) do
        if      obj.getName() == 'MegaFreeze' then
                obj.interactable = false
        elseif  obj.getDescription() == 'MegaFreeze' then
                obj.interactable = false
        else
            for _, guid in pairs(freezeByGUID) do
                if obj.getGUID() == guid then obj.interactable = false end
            end
        end
    end

     -- Freeze Objects by Zone
    for _, zone in pairs(freezeByZone) do
        for _, obj in pairs(getObjectFromGUID(zone).getObjects()) do
            obj.interactable = false
        end
    end
end


--#########################################################################
--                          ALeP UI Creation
--#########################################################################

function makeUI()
  log("Building ALeP UI")
  local alepUI = {}

  table.insert(alepUI, makeSidebar())
  table.insert(alepUI, makePlayerPanel())
  table.insert(alepUI, makeEncounterPanel())

  UI.setXmlTable(alepUI)
  log("Finished ALeP UI")
end

function makeSidebar()
    local sidebarLayout = {
      tag="VerticalLayout",
      attributes={
        id="alepUILayout",
        rectAlignment="MiddleRight",
        height=100,
        width=150,
        color="rgba(0,0,0,0.7)",
        active=flags.ui.main or false
      },
      children={}
    }

    local playerButton = {
      tag="Button",
      attributes={
        onClick="playerPanelClicked",
        tooltip="Click to spawn ALeP player cards for playtesting",
        fontSize=12,
      },
      value="Player Cards",
    }

    local encounterButton = {
      tag="Button",
      attributes={
        onClick="encounterPanelClicked",
        tooltip="Click to spawn an ALeP quest for playtesting",
        fontSize=12,
      },
      value="Quests",
    }

    local closeButton = {
      tag="Button",
      attributes={
        onClick="toggleUI",
        tooltip="Click to close ALeP Deck Builder Menu",
        fontSize=12
      },
      value="Close Menu",
    }

    table.insert(sidebarLayout.children, playerButton)
    table.insert(sidebarLayout.children, encounterButton)
    table.insert(sidebarLayout.children, closeButton)

    return sidebarLayout
end

function makePlayerPanel()
  local panel = {
    tag="Panel",
    attributes={
      id="playerPanel",
      width = "30%",
      height = "15%",
      active = flags.ui.player or false
    },
    children={}
  }

  local panelLayout = {
    tag="TableLayout",
    attributes={
      color="black",
    },
    children={}
  }

  table.insert(panelLayout.children, playerHeaderRow())
  table.insert(panelLayout.children, playerBoxRow())
  table.insert(panelLayout.children, playerSubmitRow())
  table.insert(panel.children, panelLayout)

  return panel
end

-- Player Panel Assets
function playerHeaderRow()
  local header = {
    tag="Text",
    value="ALeP Player Cards",
    attributes={
      resizeTextForBestFit=true,
      color="blue"
    }
  }

  return row({
    cell(header,2)
  })
end

function playerBoxRow()
  local label = {
    tag="Text",
    value="Pack",
    attributes={
      resizeTextForBestFit=true,
      color="Blue"
    }
  }

  local dropdown = {
    tag="Dropdown",
    attributes={
        onValueChanged="setPlayerBox"
    },
    children=generateOptions(setPlayerBox)
  }

  return row({
    cell(label),
    cell(dropdown)
  })
end

function setPlayerBox(player, option, id)
    PLAYER_BOX = option
end

function playerSubmitRow()
  local button = {
    tag="Button",
    attributes={
      onClick="playerSubmitClicked",
      fontSize=18
    },
    value="Generate Cards",
  }

  return row({
    cell(button, 2)
  })
end

function playerSubmitClicked()
    getObjectFromGUID(PLAYTEST_BUILDER).call("generateALEPPlayerCards", {playerBox = PLAYER_BOX})
    toggleUI()
end

--encounter
function makeEncounterPanel()
  local panel = {
    tag="Panel",
    attributes={
      id="encounterPanel"
      , width = "30%"
      , height = "15%"
      , active =  flags.ui.encounter or false
    },
    children={}
  }

  local panelLayout = {
    tag="TableLayout",
    attributes={
      color="black",
    },
    children={}
  }

  table.insert(panelLayout.children, encounterHeaderRow())
  table.insert(panelLayout.children, encounterPanelQuestRow())
  table.insert(panelLayout.children, encounterSubmitRow())
  table.insert(panel.children, panelLayout)

  return panel
end

function encounterHeaderRow()
  local header = {
    tag="Text",
    value="ALeP Encounter Cards",
    attributes={
      resizeTextForBestFit=true,
      color="Red"
    }
  }

  return row({
    cell(header,2)
  })
end

function encounterPanelQuestRow()
  local label = {
    tag="Text",
    value="Quest",
    attributes={
      resizeTextForBestFit=true,
      color="Red"
    }
  }

  local dropdown = {
    tag="Dropdown",
    attributes={
        onValueChanged="setQuest"
    },
    children=generateOptions(setQuest)
  }

  return row({
    cell(label)
    , cell(dropdown)
  })
end

function setQuest(player, option, id)
    QUEST_SELECTED = option
end

function encounterSubmitRow()
  local button = {
    tag="Button",
    attributes={
      onClick="encounterSubmitClicked",
      fontSize=18,
    },
    value="Generate Cards",
  }

  return row({
    cell(button, 2)
  })
end

function encounterSubmitClicked()
    getObjectFromGUID(PLAYTEST_BUILDER).call("generateALEPEncounterCards", {playerBox = QUEST_SELECTED})
    toggleUI()
end

--Generic UI Helpers

function generateOptions(setter)
  local first = true
  local options = {}
  local playtestData = getObjectFromGUID(PLAYTEST_BUILDER).getVar("PLAYTEST_DATA")
  for index, pack in pairs(playtestData.packs) do
      local title = pack.name.." - "..pack.description
      table.insert(options, option(title))
      if first then
          setter(nil, title, nil)
          first = false
      end
  end
  return options
end

function option(value)
  return {
      tag="Option",
      value=value
  }
end

function row(cells)
  return {
    tag="Row",
    attributes={},
    children=cells
  }
end

function cell(contents, colSpan)
  colSpan = colSpan or 1

  return {
    tag="Cell",
    attributes={
        columnSpan=colSpan
    },
    children=contents
  }
end

-- UI Helper Functions
function playerPanelClicked()
  UI.hide("encounterPanel")
  toggleHidden("playerPanel")
end

function encounterPanelClicked()
  UI.hide("playerPanel")
  toggleHidden("encounterPanel")
end

function toggleHidden(uiElement)
    local active = UI.getAttribute(uiElement, "active")
  -- Despite using boolean values, the attribute is a string so I have to use string matching.
  if active == "true" then
    UI.hide(uiElement)
  else
    UI.show(uiElement)
  end
end

function toggleUI()
  UI.hide("playerPanel")
  UI.hide("encounterPanel")
  toggleHidden("alepUILayout")
end
