-- ~~~~~~
-- Script by dzikakulka
-- Issues, history at: http://github.com/tjakubo2/TTS_lib
--
-- Framework for binding functions to scripting key combination press and/or release easily
-- Description and usage in README.md in this lib folder in repository
-- ~~~~~~

SHADOW_CARD_PILE = '417a35'
SECONDARY_SHADOW_CARD_PILE = '8c1795'

PLAYTEST_BUILDER = '15426a'
-- Testing flags
flags = {
  -- setTestingDeckIds = true,
  -- heroSpawnTesting = true,
  -- encounterSpawnTesting = true,
  ui = {
    -- main = true,
    -- player = true,
    -- encounter = true,
  }
}

function onLoad()
    count = 0
    spawnTest = true
        Hotkey.Bind({1}, spawnShadow, 'up')
        Hotkey.Bind({2}, spawn2ndShadow, 'up')
    MegaFreeze()
end

if not package.loaded['Hotkey'] then
    Hotkey = {}
    package.loaded['Hotkey'] = Hotkey

    -- Register the press and call any press functions
    Hotkey.onScriptingButtonDown = function(index, playerColor)
        if playerColor ~= 'Grey' then
            Hotkey.PressButton(index, playerColor)
            if Hotkey.map[Hotkey.stateTable[playerColor] .. 'D'] then
                for _,handler in pairs(Hotkey.map[Hotkey.stateTable[playerColor] .. 'D']) do
                    handler(playerColor, 'down', index)
                end
            end
        end
    end

    -- Call any release functions and then register release
    Hotkey.onScriptingButtonUp = function(index, playerColor)
        if playerColor ~= 'Grey' then
            if Hotkey.map[Hotkey.stateTable[playerColor] .. 'U'] then
                for _,handler in pairs(Hotkey.map[Hotkey.stateTable[playerColor] .. 'U']) do
                    handler(playerColor, 'up', index)
                end
            end
            Hotkey.ReleaseButton(index, playerColor)
        end
    end

    -- Hook into event functions, use EventSub if present
    if package.loaded['EventSub'] then
        EventSub.Register('onScriptingButtonDown', Hotkey.onScriptingButtonDown)
        EventSub.Register('onScriptingButtonUp', Hotkey.onScriptingButtonUp)
    else
        assert(onScriptingButtonDown == nil, 'Hotkey init: Event onScriptingButtonDown already defined!')
        function onScriptingButtonDown(...)
            Hotkey.onScriptingButtonDown(table.unpack({...}))
        end
        assert(onScriptingButtonUp == nil, 'Hotkey init: Event onScriptingButtonUp already defined!')
        function onScriptingButtonUp(...)
            Hotkey.onScriptingButtonUp(table.unpack({...}))
        end
    end

    -- Amount of available buttons
    Hotkey.keyCount = 10
    -- Create a string representing press combination for easy comparision
    Hotkey.PressString = function(combination)
        local out = ''
        for k=1,Hotkey.keyCount do
            out = out .. '-'
        end
        if combination then
            for _,index in pairs(combination) do
                out = out:sub(1, index-1) .. '+' .. out:sub(index+1)
            end
        end
        return out
    end

    -- Main table containing info on player keypresses
    Hotkey.stateTable =  {
            ['White'] = Hotkey.PressString(),
            ['Brown'] = Hotkey.PressString(),
            ['Red'] = Hotkey.PressString(),
            ['Orange'] = Hotkey.PressString(),
            ['Yellow'] = Hotkey.PressString(),
            ['Green'] = Hotkey.PressString(),
            ['Teal'] = Hotkey.PressString(),
            ['Blue'] = Hotkey.PressString(),
            ['Pink'] = Hotkey.PressString(),
            ['Purple'] = Hotkey.PressString(),
            ['Black'] = Hotkey.PressString()
    }

    -- Map of combination strings to a table of handler functions
    Hotkey.map = {}

    -- Add a handler function for a combination
    Hotkey.Bind = function(combination, handler, direction)
        assert(type(combination) == 'table', 'Hotkey.Bind: combination not a table!')
        assert(type(handler) == 'function', 'Hotkey.Bind: handler not a function!')
        direction = direction or 'down'
        local pressString = Hotkey.PressString(combination)
        if direction == 'up' or direction == 'any' then
            if not Hotkey.map[pressString .. 'U'] then
                Hotkey.map[pressString .. 'U'] = {}
            end
            table.insert(Hotkey.map[pressString .. 'U'], handler)
        end
        if direction == 'down' or direction == 'any' then
            if not Hotkey.map[pressString .. 'D'] then
                Hotkey.map[pressString .. 'D'] = {}
            end
            table.insert(Hotkey.map[pressString .. 'D'], handler)
        end
    end

    -- Register button press in state tables
    Hotkey.PressButton = function(index, playerColor)
        if Hotkey.stateTable then
            Hotkey.stateTable[playerColor] = Hotkey.stateTable[playerColor]:sub(1, index-1) .. '+' ..  Hotkey.stateTable[playerColor]:sub(index+1, -1)
        end
    end
    -- Register button release in state tables
    Hotkey.ReleaseButton = function(index, playerColor)
        if Hotkey.stateTable then
            Hotkey.stateTable[playerColor] = Hotkey.stateTable[playerColor]:sub(1, index-1) .. '-' ..  Hotkey.stateTable[playerColor]:sub(index+1, -1)
        end
    end
end

function spawnShadow(playerColor, direction, lastPressIndex)
    function spawnShadow_afterCount(prams)
        local num = prams.n
        local pos = prams.p
        pos.y = 4
        for _, d in pairs(getObjectFromGUID(SHADOW_CARD_PILE).getObjects()) do
            if d.tag == 'Deck' then
                if #d.getObjects() < num then num = #d.getObjects() end
                local p = {position=pos, rotation={0,180,180}}
                for i=1, num, 1 do
                    d.takeObject(p)
                    p.position.x = p.position.x
                end
            elseif d.tag == 'Card' then
                d.setPositionSmooth(pos)
                d.setRotation({0,180,180})
            end
        end
        count = 0
        spawnTest = true
    end
    count = count + 1
    if spawnTest then pos = Player[playerColor].getPointerPosition() spawnTest = false end
    local prams = {n=count, p=pos}
    Timer.destroy("spawnShadow1"..playerColor)
    Timer.create({
        identifier="spawnShadow"..playerColor, delay=0.2,
        function_name="spawnShadow_afterCount", function_owner=self, parameters = prams,
    })
end

function spawn2ndShadow(playerColor, direction, lastPressIndex)
    function spawnShadow_afterCount(prams)
        local num = prams.n
        local pos = prams.p
        pos.y = 4
        for _, d in pairs(getObjectFromGUID(SECONDARY_SHADOW_CARD_PILE).getObjects()) do
            if d.tag == 'Deck' then
                if #d.getObjects() < num then num = #d.getObjects() end
                local p = {position=pos, rotation={0,180,180}}
                for i=1, num, 1 do
                    d.takeObject(p)
                    p.position.x = p.position.x
                end
            elseif d.tag == 'Card' then
                d.setPositionSmooth(pos)
                d.setRotation({0,180,180})
            end
        end
        count = 0
        spawnTest = true
    end
    count = count + 1
    if spawnTest then pos = Player[playerColor].getPointerPosition() spawnTest = false end
    local prams = {n=count, p=pos}
    Timer.destroy("spawnShadow1"..playerColor)
    Timer.create({
        identifier="spawnShadow"..playerColor, delay=0.2,
        function_name="spawnShadow_afterCount", function_owner=self, parameters = prams,
    })
end

Total = getObjectFromGUID('639e23')
Levels = getObjectFromGUID('5a5f95')
Bonus = getObjectFromGUID('639e23')

function addUp() -- TODO: Is this still used?
    Total.setValue( Levels.getValue() + Bonus.GetValue() )
end

function MegaFreeze()
    local freezeByZone = {'36c7bf'}
    --black table, left edge, right edge, top edge, vd, aside, floor (table), secret bag under the black table, another secret bag under the black table
    local freezeByGUID = {'23a43c', 'b37a40', 'b3e425', 'e577da', '2a71e5', 'eef28d', '1d2bbf', '9ef8b0', 'ce199b'}

    for _, obj in pairs(getAllObjects()) do
        if      obj.getName() == 'MegaFreeze' then
                obj.interactable = false
        elseif  obj.getDescription() == 'MegaFreeze' then
                obj.interactable = false
        else
            for _, guid in pairs(freezeByGUID) do
                if obj.getGUID() == guid then obj.interactable = false end
            end
        end
    end

     -- Freeze Objects by Zone
    for _, zone in pairs(freezeByZone) do
        for _, obj in pairs(getObjectFromGUID(zone).getObjects()) do
            obj.interactable = false
        end
    end
end


--#########################################################################
--                          ALeP UI Creation
--#########################################################################

function makeOverlay()
    log("Building ALeP UI - NEW")
    local fullPanelLayout = {
        tag="Panel",
        attributes = {
            id="mainLayout",
            width="680",
            height="500",
            rectAlignment="UpperCenter",
            offsetXY="0 -250",
            allowDragging="true",
            showAnimation="FadeIn",
            showAnimationDelay="2",
            returnToOriginalPositionWhenReleased="false",
            color="#f3b86d",--"#8F8478",
            outline="#635351",
            outlineSize="2 -2",
            active=flags.ui.main or false
        },
        children = {}
    }

    local scrollArea = {
        tag="VerticalScrollView",
        attributes = {
            id="mainScrollArea",
            rectAlignment="LowerCenter",
            offsetXY="0 -00",
            scrollSensitivity="40",
            padding="0 0 50 0",
            scrollbarColors="#AD9F91|#C9B9A9|#756C63|rgba(0.78,0.78,0.78,0.5)",
            width="680",
            height="480",
            color="#7b8a62"--"#8eb54c"--"#b9de7a"--"#DDDDDD"
        },
        children = {}
    }

    local gridLayout = {
        tag="GridLayout",
        attributes = {
            id="mainGrid",
            padding="0 0 8 3",
            spacing="8 8",
            height="600",
            cellsize="150 100",
            childAlignment="UpperCenter"
        },
        children = {}
    }

    local playtestData = getObjectFromGUID(PLAYTEST_BUILDER).getVar("PLAYTEST_DATA")
    for index, pack in pairs(playtestData.packs) do
        if pack.active then
            -- If player cards exist in pack
            if pack.playerCards then
                local title = pack.name.." "..pack.description.." - Player Cards"
                local gridButton = {
                    tag="Button",
                    attributes = {
                        id="button_player_"..index,
                        padding="5 5 10 0",
                        textColor="#626262",--"#FFFFFF",
                        colors="#f3b86d|#C9B9A9|#756C63|rgba(0.78,0.78,0.78,0.5)",--"#AD9F91|#C9B9A9|#756C63|rgba(0.78,0.78,0.78,0.5)",
                        onClick="gridButtonClicked",
                        text=title
                    },
                    children = {}
                }
                table.insert(gridLayout.children, gridButton)
            end
            -- If encounter cards exist in pack
            if pack.encounterCards then
                local title = pack.name.." "..pack.description.." - Encounter Deck"
                local gridButton = {
                    tag="Button",
                    attributes = {
                        id="button_encounter_"..index,
                        padding="5 5 10 0",
                        textColor="#f3b86d",
                        colors="#626262|#91867a|#756C63|rgba(0.78,0.78,0.78,0.5)",
                        onClick="gridButtonClicked",
                        text=title
                    },
                    children = {}
                }
                table.insert(gridLayout.children, gridButton)
            end
        end
    end

    local closeButton = {
        tag="Button",
        attributes = {
            id="closeButton",
            width="20",
            height="20",
            rectAlignment="UpperRight",
            color="#990000",
            textColor="#FFFFFF",
            text="X",
            onClick="toggleOverlay"
        },
        children = {}
    }

    local fullPanelText = {
        tag="Text",
        attributes = {
            text="Choose a Pack",
            alignment="UpperLeft",
            fontSize="18",
            offsetXY="5 0",
            fontStyle="Bold",
            color="#626262"--"#FFFFFF"
        },
        children = {}
    }

    table.insert(scrollArea.children, gridLayout)
    table.insert(fullPanelLayout.children, scrollArea)
    table.insert(fullPanelLayout.children, closeButton)
    table.insert(fullPanelLayout.children, fullPanelText)
    UI.setXmlTable({fullPanelLayout})
    log("Finished ALeP UI - NEW")
end

function gridButtonClicked(player, value, id)
    local buttonIds = {}
    for token in string.gmatch(id, "[^_]+") do
        table.insert(buttonIds, token)
    end
    getObjectFromGUID(PLAYTEST_BUILDER).call("generateALEPCards", {packID = buttonIds[3], packType = buttonIds[2]})
    toggleOverlay()
end

--Generic UI Helpers

function option(value)
  return {
      tag="Option",
      value=value
  }
end

function row(cells)
  return {
    tag="Row",
    attributes={},
    children=cells
  }
end

function cell(contents, colSpan)
  colSpan = colSpan or 1

  return {
    tag="Cell",
    attributes={
        columnSpan=colSpan
    },
    children=contents
  }
end

-- UI Helper Functions
function toggleOverlay()
    toggleHidden("mainLayout")
end

function toggleHidden(uiElement)
    local active = UI.getAttribute(uiElement, "active")
    if active == "true" then
        UI.hide(uiElement)
    else
        UI.show(uiElement)
    end
end
